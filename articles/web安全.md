## 常见攻击方式

三月份面试腾讯，深深的感受到了自己基础的薄弱，总结了一下web安全方面的知识

一般说来，在Web安全领域，常见的攻击方式大概有以下几种：

1. SQL注入攻击
2. 跨站脚本攻击 - XSS
3. 跨站伪造请求攻击 - CSRF
4. 文件上传漏洞攻击
5. 分布式拒绝服务攻击 - DDOS

### SQL注入

SQL注入就是在执行数据库操作的时候，用户上传的数据中带有特殊字符或者可以使程序不按照设计者意图去执行SQL语句。现在的很多ORM框架其实已经帮我们做了很多防止SQL注入的工作，导致我在写项目时可能并不会意识到这个问题，SQL注入河大程度上是开发时对于数据校验的不够严格，导致非法的变量被传入到数据库操作的过程中，最根本的问题也就是：验证用户上传参数的正确性，在数据库操作时使用预编译语句绑定参数。下面是防止SQL注入的一些方法：

1. 检查变量数据类型和格式

   只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式

2. 过滤特殊符号,特殊字符转义

   对于无法确定固定格式的变量，一定要进行特殊符号过滤或转义处理。以PHP为例，通常是采用addslashes函数，它会在指定的预定义字符前添加反斜杠转义，这些预定义的字符是：单引号 (') 双引号 (") 反斜杠 (\) NULL。

3. 绑定变量，使用预编译语句

   **实际上，绑定变量使用预编译语句是预防SQL注入的最佳方式**，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构。

   ```sql
   -- user/delete?id=1
   DELETE FROM user WHERE id = 1;
   -- user/delete?id=1 or 1=1
   DELETE FROM user WHERE id = i OR 1 = 1;
   ```


### 小结

1. 不要随意开启生产环境中Webserver的错误显示。
2. 永远不要信任来自用户端的变量输入，有固定格式的变量一定要严格检查对应的格式，没有固定格式的变量需要对引号等特殊字符进行必要的过滤转义。
3. 使用预编译绑定变量的SQL语句。这也是防止SQL注入的最佳方式。
4. 做好数据库帐号权限管理。例如，用户操作的数据库连接的用户就不应该让其拥有可以删除数据的权限，有些线上环境中还在用root连接数据库的就是自己找死。
5. 严格加密处理用户的机密信息。

### XSS

跨站脚本攻击(Cross Site Scripting)，为了不和伟大的 ``CSS`` 的缩写混淆，故将跨站脚本攻击缩写为XSS。XSS是通过在网页上嵌入恶意代码，通常是js的代码，在用户进行特定操作的时候注入恶意脚本并触发，从而达到获取用户数据或者更改DOM结构。

那么，XSS通常在什么样的情况下发生呢，个人肤浅的认为，除了各种钓鱼网站，应该没有开发者给自己的web程序注入恶意脚本，就算是用户这么做了，也不算XSS，明明是自己注入的嘛，在通过正常的途径访问正规的网站时，XSS发生的几率并不大，脚本注入的难度也是很大的，但是，如果我们点了一些什么弹窗小广告，通过非正规渠道进入一个网站，那么这个网站的页面可能就并不是网站本来的信息，很可能经过了处理，被注入了恶意脚本。

以下是MDN的原文

> 在以下2种情况下，容易发生XSS攻击
>
> 1）数据从一个不可靠的链接进入到一个web应用程序。
>
> 2）没有过滤掉恶意代码的动态内容被发送给web用户。

XSS的危害在于，这些恶意脚本可能会将你的本地敏感信息，如cookie，session，存储在本地的用户权限验证token等，这样攻击者就可以进行恶意操作了。

XSS攻击分为三种：存储型（持久型）、反射型（非持久型）、基于DOM。

- 存储型：直接将恶意代码存储在服务器中，任何用户访问这个web页面时，都会将恶意脚本回传并执行，危害面积就很广了。
- 反射型：当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。浏览器会执行这段脚本，因为，它认为这个响应来自可信任的服务器。
- 基于DOM 改变页面的结构。

### 解决办法

道高一尺，魔高一丈，完全解决这些攻击基本上是一件不肯能的事情，但是，我们可以增加用户进行攻击的难度，最起码使得攻击的成本大于黑客可以获得的信息的价值，或者让攻击的的成本超过你整个平台的成本，那么，攻击者再攻击你的网站干什么呢，他可能脑壳疼。

对输入和URL参数进行过滤，对输出进行编码cookie设置http-only编码，说白了还是：用户的任何输入都是不可信任的，要在valiation层进行严格的数据验证，使用户的输入符号预期，同时也可以对输出进行编码，使得即便已经有代码被植入，也让他无法执行。

### CSRF

CSRF(Cross-site request forgery)跨域请求伪造，攻击方通过伪造用户请求访问受信任站点。当我们在登录了一个网站之后验证信息如session就会存储在本地存储之中，此时我们再打开一个危险的网站，此网站在此时就可能会给我们刚刚已经登录受信任的网站发送一个请求操作，如操作转账操作，这时，请求的地址已经受信任，操作者只需要将请求参数更改为他的目标参数发起请求，浏览器就会携带受信任的用户凭证去请求接口，那么请求自然就会成功。如果这个操作是get请求那么黑客伪造请求的代价就会十分低廉，如果是post请求，相对get是更难的，但是一样可以实现，通过在恶意网站添加一个隐藏表单，在通过js在用户加载恶意网站或者进行预定义的操作时触发表单请求，那么也会携带用户凭证请求已经受信任的服务器，造成危害。

### 解决办法

1. 在涉及到数据操作的时候，肯定是不能使用get的，最好遵循RESTFUL的风格，即规范开发，也规避风险。
2. 操作时加入验证码，这样即便是post被伪造，也可以在一定程度上被抵御
3. 验证Refer(当前请求的来源地址) 只信任特地地址发起本次请求的网站(refer有被篡改的风险)
4. anti CSRF token 这是最常用也是最有效的方法，在每一次涉及到数据更改的请求中(对，我忽略了那些get修改数据作死的兄弟)都生成一个随机的csrf_token,这个token只有本次请求有效，那么在请求数据修改的操作发生之后，服务器不仅验证session或token登录信息，还要验证本次的请求携带的csrf_token是否有效，如果有效，就放行本次请求，同时清除服务器端缓存的本次请求携带的csrf_token，如果用户再次携带这个csrf_token请求数据，validation就会 failure，使得伪造请求的难度大幅增长。
5. 加自定义的Heather 简单理解在header中传输csrf_token

### 文件上传漏洞

文件上传漏洞是用户在网站上上传文件或者图片等资源上传操作时上传了可执行文件，使得可执行文件在服务器端被执行，文件上传成功后，可以通过url去访问文件，那么可执行文件就会被执行。所以说道底问题依旧出在validation层上，同时还有一个很好的解决方案或者说降低风险的方式就是文件服务器与应用服务器的分离，这样即便文件服务器被植入了可执行文件，但是，如果只是植入了需要特定环境的代码如php，那么文件服务器不一定拥有执行的环境，风险也会随之降低。

### 解决方案(这个是抄来的)

对于上传文件的后缀名（扩展名）没有做较为严格的限制
对于上传文件的MIMETYPE 没有做检查
权限上没有对于上传的文件的文件权限，（尤其是对于shebang类型的文件）
对于web server对于上传文件或者指定目录的行为做限制



### 分布式ddos攻击

个人理解，看似正常的大规模访问搞崩服务器，所以，检测是不是僵尸用户可以拒接僵尸用户进行操作，但是这个难度时很大的，所以，对待网站可面临的ddos，就如同阿里大神对待双十一，增大网站的并发能力是很通用的办法。我经验实在不足，牛B也只能吹到这里了，n年之后在来看我自己写的文章不知道会不会笑出猪叫声。

## 总结

所有用户传入数据都不可信，服务器端必须对用户传入的参数进行严格的validation，严格、严格、在严格！。