# Spring Transaction

Spring支持两种类型的事务管理：

1. 编程式事务管理: 通过编程的方式管理事务，带来极大的灵活性，但难维护
2. 声明式事务管理: 通过注解和xml配置来管理事务，实现业务代码与事务管理的解耦

Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。

Spring有五大隔离级别:

| 事务隔离级别               | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ISOLATION_DEFAULT          | 用底层数据库的设置隔离级别，数据库设置的是什么我就用什么，Spring的默认配置 |
| ISOLATION_READ_UNCOMMITTED | 读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）； |
| ISOLATION_READ_COMMITTED   | 提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别、Oracle的默认级别； |
| ISOLATION_REPEATABLE_READ  | 可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别； |
| ISOLATION_SERIALIZABLE     | 序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 |

Spring的事务传播行为是框架独有的事务增强特性，不属于数据库行为。

Spring的事务传播行为:

| 事务传播行为类型          | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| PROPAGATION_REQUIRED      | 如果当前没有事务,就创建一个新事务，否则就加入该事务，该设置是最常用的设置 |
| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前存在事务,就加入该事务，否则就以非事务执行 |
| PROPAGATION_MANDATORY     | 支持当前事务，如果当前存在事务，就加入该事务，否则抛出异常   |
| PROPAGATION_REQUIRES_NEW  | 创建新事务，无论当前存不存在事务，都创建新事务               |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起     |
| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务就抛出异常                 |
| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行，否则按REQUIRED属性执行 |